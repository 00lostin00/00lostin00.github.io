[{"content":"LIS ：最长单调上升子序列。 LCS：最长公共子序列。\nLIS 考虑 $O(n)$ 单调上升子序列， 易得出一下代码，\n1 2 3 4 5 6 7 8 9 for(int i=1;i\u0026lt;=n;i++) { f[i]=1; for(int j=1;j\u0026lt;i;j++) { if(a[i]\u0026gt;=a[j]) f[i]=max(f[i],f[j]+1); } } 可优化为 $O(nlogn)$，考虑单调栈，每次往栈内压入一个 $x$ 保证 $f_{j\u0026rsquo;\u0026rsquo;}\u0026lt;x\u0026lt;f_{j\u0026rsquo;},j\u0026rsquo;\u0026rsquo;\u0026lt;j\u0026rsquo;$ ，所以原来栈内元素中把 $f_{j\u0026rsquo;}$ 弹出用 $x$ 替换掉，即 $f_{j\u0026rsquo;}=x$ 。保证栈内单调，且优先每个最大子段数保证递增的末尾数值尽可能的小。 而如何求出来 $j\u0026rsquo;$ ，一种是模拟的求，$O(n)$，由于栈内保证单调，所以也可以二分求出来 $O(logn)$ 。 当然一般会用 $k=lower_bound(f+1,f+t+1,x)-f$ 来求。 代码展示\n1 2 3 4 5 6 for (int i = n; i \u0026gt;= 1; i--) { int k = upper_bound(f + 1, f + ans + 1, a[i]) - f; f[k] = a[i]; ans = max(ans, k); } LCS 首先考虑朴素的公共子序列问题 典型的区间 $dp$ 问题\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); if (a1[i] == a2[j]) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1); // 因为更新，所以++； } 回文也可以简单的理解为颠转顺序来求正反串的最大公共子序列。 考虑找到最大公共子序列，用强制定义顺序，来使 LCS转换成LIS问题。\n对于任意两段数字内容序列，首先将其离散化，对任意序列强行定义顺序，在将另一序列用定义的顺序替换即可。 $for$ $example$ 3 2 1 4 5 4 2 3 5 1 将第二个队列用 1 2 3 4 5强行定义递增顺序，第一队列按照第二队列对应的方式一一映照即可。 得出3 2 5 1 4 然后再在3 2 5 1 4中找LIS就是该两队列中的LCS。 映射代码：\n1 2 3 4 5 6 for (int i = 1; i \u0026lt;= n; i++) { int x; cin\u0026gt;\u0026gt; x; v[x] = i; } ","date":"2024-09-25T22:02:59+08:00","permalink":"http://localhost:1313/p/lis%E5%92%8Clcs%E9%97%AE%E9%A2%98/","title":"LIS和LCS问题"},{"content":"$KMP$ 算法中的 $.next$ 数组本质就是求最长的相同前后缀的长度。 对于一般的字符串匹配，需要进行朴素的遍历，$kmp$ 算法是保证被遍历的字符串不动，让子串按照$.next$ 数组进行遍历。 主串是 $O(n)$ 遍历的，在遍历时只需要判断是否可以相等，相等的话持续下去，不相等的话跳到 $.next$ 数组对应的位置。 $.next$ 数组求法本质上是子串自己遍历子串\n1 2 3 4 5 6 7 8 9 string s; int j=0;//可以理解为子链上的指针 for(int i=2;i\u0026lt;=length;i++)//第一个不能被本身遍历，要不然就是整个串遍历完了 { while(j\u0026amp;\u0026amp;s[j+1]!=s[i])//j=0就是起始点了不用跳了，另一种是跳的过程中发现可以匹配上，也退出 j=kmp[j];//如果发现j+1无法匹配的时候就跳到.next数组的地方 if(s[j+1]==s[i])j++;//即匹配成功，子链向后移动 kmp[i]=j;//以i点为后缀，可以找到最大的相同的前缀 } $ABABCABBABCA$ 0 0 1 2 0 1 2 0 1 2 0 1\n那么遍历主串就简单多了\n1 2 3 4 5 6 7 8 9 string a,b; int j=0; for(int i=1;i\u0026lt;=la;i++) { while(j\u0026amp;\u0026amp;b[j+1]!=a[i])j=kmp[j]; if(a[i]==b[j+1])j++; //可以选择继续遍历下去，也可以在j==lb的时候直接退出 if(j==lb)j=kmp[j]; } 总之，时常练习，别忘了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int kmp[213123123]; string a,b; int main () { getline(cin,a);getline(cin,b); int la=a.size(); int lb=b.size(); int j=-1;kmp[0]=-1; for(int i=1;i\u0026lt;lb;i++) { while(j\u0026gt;=0\u0026amp;\u0026amp;b[j+1]!=b[i])j=kmp[j]; if(b[j+1]==b[i])j++; kmp[i]=j; } //for(int i=0;i\u0026lt;lb;i++)cout\u0026lt;\u0026lt;kmp[i]+1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; j=-1; for(int i=0;i\u0026lt;la;i++) { while(j\u0026gt;=0\u0026amp;\u0026amp;a[i]!=b[j+1])j=kmp[j]; if(b[j+1]==a[i])j++; if(j==lb-1){cout\u0026lt;\u0026lt;i-lb+2\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;} } for(int i=0;i\u0026lt;lb;i++)cout\u0026lt;\u0026lt;kmp[i]+1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } ","date":"2024-09-25T22:01:06+08:00","permalink":"http://localhost:1313/p/kmp%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"KMP字符串匹配"},{"content":" 嗯！ 题目有P3371 【模板】单源最短路径（弱化版），P4779 【模板】单源最短路径（标准版）。\n之后还有个Dijkstra的反复横跳的大水题P4943（哈利与罗恩的奇妙冒险）。\n还是分析一下这个算法吧。\n这边说一下我不会画电子版的图所以就看我的语文功底好不好吧。\n存在二维的最短路小红走矩阵)\n建图 对于一个图，首先得确定拿什么方式来建图和存图。\n刚开始可能会拿邻接矩阵来搞（然后就发现“茫茫世间，尽是大漠一片”）\n看过深入浅出的可能会拿vector数组来存，但是不方便。\n还有拿链式表，还有拿前向星的，这两个都很好就是各自都有互补的缺点，于是乎就有了“链式前向星”。\n关于前向星的思路我大概叙述一下，网上有很多的讲解比我的都好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n,m,cnt; struct Edge { int to,w,next; }edge[maxn]; int head[maxn]; void init () { for(int i=0;i\u0026lt;=n;i++)head[i]=-1; cnt=0; } void add_edge(int u,int v,int w) { edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++;//这个是先让head[u]=cnt，然后让cnt=cnt+1； } 这个东西是以边cnt来存路径的，三个点u,v,w，分别为起点，终点，权值。而.next为下（亦可以理解为上一条边）一条边，head数组就是以某一个点u连接的某些边的集合，这个要将每个顶点连的第一条边都赋值为“-1”，因为当所有的边都遍历完了，“-1”就是退出循环的标志。\n每个序号有唯一的边，但每个边不一定只有一个序号来对应就像函数y（边）和x（序号）的关系。\n枚举过程是以某个边cnt连接的起点来枚举这个点的所有边，但不用存有几条边，因为最后会连接到\u0026quot;-1\u0026quot;就终止循环了。\n这是枚举用的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 for(int i=1;i\u0026lt;=n;i++) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; for(int j=head[i];j!=-1;j=edge[j].next) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;edge[j].to\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;edge[j].w\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;endl; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; for (int j = h[i]; j != -1; j = e[j].nt) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e[j].to \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } 然后我们来考虑Dijkstra的算法分析。\nDijkstra 问题:以某个点s为起点到该图所有的点的最小权值。\n看图工具\n造个数据,\n1 2 5 1 5 2 1 3 1 1 4 3 2 5 1 3 2 1 3 4 1 （比较拉跨）\n对于这个图从$1$可以到4个点，然后我们枚举四个点的权值，之后该干嘛？\n答：找最小值。因为当某个路径的权值是所有路径中最小值的时候，那么它就更有重复被其他点当作路径的可能。\n比如：1-\u0026gt;4直接走权值就是3，但是1-\u0026gt;3-\u0026gt;4权值只有2，也就是dis[1-\u0026gt;3]+dis[3-\u0026gt;4]\u0026lt;dis[1-\u0026gt;4],则dis[1-\u0026gt;4]=dis[1-\u0026gt;3]+dis[3-\u0026gt;4]。\n这时比较聪明的就立刻举手，从1-\u0026gt;2是5而1-\u0026gt;5-\u0026gt;2只有3。不过1-\u0026gt;3-\u0026gt;2只有2，所以它的最小权值就是2。\n这样就是先走最小的边，然后再考虑后面的边，这样就可能得到的路径的权值比原来的更小。\n不过一旦我们找到到达这个点的最小值了，那么就不需要考虑到达的这个点的枚举了，所以就需要用$visit$数组做一个标记，这个点到过了就标记一下下一个点就不会再重复枚举了。\n我们把这个点对应的路径的权值都算出来，然后找最小的权值对应的点再枚举路径再找到最小的点，直到该点所连接的点均到过就结束循环。\n所以这个的大体思路就有了，就是先找一个点，然后把这个点的所有边都枚举一遍找到最小值的路径对应的点并标记一下，再枚举一遍这个点对应的边，再次找到最小值，再枚举。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void Dijkstra() { int minn,pos; while(1) { minn=inf,pos=-1; for(int i=1;i\u0026lt;=n;i++) { if(!visit[i]\u0026amp;\u0026amp;dis[i]\u0026lt;minn) { minn=dis[i],pos=i; } } if(pos==-1)break; visit[pos]=1; for(int i=h[pos];i!=-1;i=edge[i].next) { int t=edge[i].to; if(!visit[t]\u0026amp;\u0026amp;dis[t]\u0026gt;dis[pos]+edge[i].w) dis[t]=dis[pos]+edge[i].w; } } return ; } 但是， 这样不会太慢吗，每次都得作比较，就跟我的快排艺术差不多了。\n所以这边就需要用到优先队列。\n首先先说明优先队列是干什么的。\n它就是可以简单的理解为你往队列里面堆入一个值它可以将这个值按照你的定义来排序（比如：从大到小或者从小到大）。\n而这个是怎么实现的呢？就是在结构体里面自定义一下。\n1 2 3 4 5 6 7 struct nihao{ int a;int b; bool operator\u0026lt;(const nihao \u0026amp; u) const { return a\u0026gt;u.a; } }m; 这里面const nihao \u0026amp; u指的是往这个队列里堆入一个结构类型为nihao的变量，让这个变量的.a和这个队列里的.a的数作比较返回一个大的值也就是从大到小排序。\n而对于Dijkstra则是从小到大的排序，也就是用了优先队列就不用一个个的比最小值了，只需要把这个数据堆入自动排序，如果用的时候再弹出队列就行了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void Dijkstra() { while(!q.empty()) { node temp=q.top(); q.pop(); int x=temp.pos,d=temp.dis; if(!visit[x]) { visit[x]=1; for(int i=h[x];i!=-1;i=edge[i].next) { int t=edge[i].to; if(!visit[t]\u0026amp;\u0026amp;dis[t]\u0026gt;dis[x]+edge[i].w) dis[t]=dis[x]+edge[i].w,q.push((node){dis[t],t}); } } } return ; } 以上就叙述完了。\n所以一个Dijkstra的完整代码搁这了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;algorithm\u0026gt; #define mm 20000001 #define inf 0x7fffffff using namespace std; int n,m,s,cnt; int h[2000001],dis[mm]; bool visit[mm]; struct Edge{ int to,w,next; }edge[2000001]; struct node { int dis; int pos; bool operator \u0026lt;( const node \u0026amp;x )const { return x.dis \u0026lt; dis; } }; priority_queue\u0026lt;node\u0026gt;q; void init () { memset(visit,0,sizeof(visit)); memset(dis,0x3f,sizeof(dis)); memset(h,-1,sizeof(h)); } void add(int u,int v,int w) { edge[cnt].to=v,edge[cnt].w=w,edge[cnt].next=h[u],h[u]=cnt++; } void pintf() { for(int i=1;i\u0026lt;=n;i++) { cout\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } void Dijkstra() { while(!q.empty()) { node temp=q.top(); q.pop(); int x=temp.pos,d=temp.dis; if(!visit[x]) { visit[x]=1; for(int i=h[x];i!=-1;i=edge[i].next) { int t=edge[i].to; if(!visit[t]\u0026amp;\u0026amp;dis[t]\u0026gt;dis[x]+edge[i].w) dis[t]=dis[x]+edge[i].w,q.push((node){dis[t],t}); } } } return ; } int main () { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; init(); for(int i=1;i\u0026lt;=m;i++) { int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; add(a,b,c); } dis[s]=0; q.push((node){0,s}); Dijkstra(); pintf(); return 0; } OVER!\n","date":"2024-09-25T21:54:41+08:00","permalink":"http://localhost:1313/p/%E6%9C%80%E7%9F%AD%E8%B7%AF-dijkstra/","title":"最短路 Dijkstra"},{"content":"","date":"2024-09-25T21:53:01+08:00","permalink":"http://localhost:1313/p/%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/","title":"算法大纲"},{"content":"QAQ/꒰ঌ( 🎀ᗜ`˰´ᗜ🌸 )໒꒱💈× 出题人题解 题意：有 $n$ 个人正在发癫，已知有 $m$ 个它们可能对着发癫的 Vtuber 且每个人有两个推的 Vtuber ，保证这两位 Vtuber 不同且没有任意两个人推的两位 Vtuber 完全一致，这些人只有可能对着自己推的 Vtuber 发癫。\n试问有没有可能每个人对着发癫的 Vtuber 各不相同，若有，请给出一种可能的情况。\n多测，$T\\le 10^5,\\sum n,\\sum m \\le 2\\times 10 ^6$。\n子任务分布如下：\n20分算法： 直接爆搜 $2^n$ 种可能的情况，每次 $\\Theta(m)$ 判断。\n时间复杂度 $\\Theta(\\sum m2^n)$，视常数和剪枝情况可以拿到 $20-25$ 分。\n50分算法： 我们考虑在 Vtuber 和颠佬之间连边，将两者分别视作二分图的左部与右部，求整张图的二分图最大匹配，当匹配数为 $n$ 时即为合法，输出求出的任意一种匹配即可。\n考虑匈牙利算法，整张图的点数为 $n+m$，边数为 $2n$ ，时间复杂度为 $\\Theta(n^2+nm)$ 级别。\n加上卡常，实际最多可以获得 $60$ 分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 //written by Amekawa_kanade #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; void syncoff()//fuck you sync { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); } #define endl \u0026#39;\\n\u0026#39; const int N=6e6+11; using ll=long long; using i128=__int128; using ld=long double; const ll JT=998244353; const ll GEH=1e9+7; const ll ZLH=1e9+9; const int inf=INT_MAX-1; int t,n,k,m,q; struct edge { int to,nxt; }G[N*2];int cnt1,H1[N],vnm;bool vis[N]; int gt[N]; void add_edge(int u,int v) { G[cnt1]=edge{v,H1[u]};H1[u]=cnt1++; } void add_r(int u,int v) { add_edge(u,v),add_edge(v,u); } bool augment(int u) { for(int i=H1[u];i!=-1;i=G[i].nxt) { int v=G[i].to; if(!vis[v]) { vis[v]=1; if(!gt[v]||augment(gt[v])) { gt[v]=u; gt[u]=v; return 1; } } } return 0; } void clear() { for(int i=1;i\u0026lt;=vnm;++i) vis[i]=gt[i]=0; cnt1=0,vnm=0; } int _s,_t; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vnm=n+m;for(int i=1;i\u0026lt;=vnm;++i) H1[i]=-1; for(int i=1;i\u0026lt;=n;++i) { int iu,iv;cin\u0026gt;\u0026gt;iu\u0026gt;\u0026gt;iv; add_edge(i,iu+n); add_edge(i,iv+n); } int chk=0; for(int i=1;i\u0026lt;=n;++i) fill(vis+1,vis+vnm+1,0),chk+=augment(i); if(chk\u0026lt;n) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl;return clear(); } else cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; //for(int i=0;i\u0026lt;=cnt1;++i) cout\u0026lt;\u0026lt;G[i].to\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=n;++i) { cout\u0026lt;\u0026lt;gt[i]-n\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; return clear(); } void file(string file) { freopen((file+\u0026#34;.in\u0026#34;).c_str(),\u0026#34;r\u0026#34;,stdin); freopen((file+\u0026#34;.out\u0026#34;).c_str(),\u0026#34;w\u0026#34;,stdout); } /* 1 5 5 1 3 4 5 2 5 1 4 3 5 */ int main() { //file(\u0026#34;19\u0026#34;); syncoff(); cin\u0026gt;\u0026gt;t; while(t--) solve(); return 0; } 特殊性质：B 考虑给出 $n+m$ 个点的图，随机在左右两部连 $2n$ 条不重的边，让左部每一个点都能够得到匹配的概率极低。\n又考虑到这些测试点的 $T$ 都很小，我们大胆猜测：此时有极大的概率无解。\n我们考虑卡时或直接特判 $T=2$ 或 $T=6$ ，直接全部输出 NO 。\n60分算法： 我们考虑一些治标不治本的东西：加速二分图最大匹配。\n二分图最大匹配可以转换成最大流：源点往所有左部点连一条弧，左部与右部的边替换为由左部往右部连的一条弧，右部每个点往汇点连一条弧，所有弧的容量均设为 $1$ ，这张网络的最大流即为二分图最大匹配数，查看匹配只需要看反向弧流量。\n这种网络的点数与弧数均为 $n+m$，使用Dinic算法可以做到 $\\Theta((n+m)\\sqrt {n+m})$ 的时间复杂度。\n相信Dinic算法的优秀常数，卡卡常，下面给出实际得分 $75$ 分的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 //written by Amekawa_kanade #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; void syncoff()//fuck you sync { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); } #define endl \u0026#39;\\n\u0026#39; const int N=6e6+11; using ll=long long; using i128=__int128; using ld=long double; const ll JT=998244353; const ll GEH=1e9+7; const ll ZLH=1e9+9; const int inf=INT_MAX-1; int t,n,k,m,q; struct edge { int to,nxt,cap; }G[N*2];int cnt1,H1[N],vnm;vector\u0026lt;int\u0026gt; dis,rad; void add_edge(int u,int v,int val) { G[cnt1]=edge{v,H1[u],val};H1[u]=cnt1++; } void add_r(int u,int v,int val) { add_edge(u,v,val),add_edge(v,u,0); } bool delaminate(int s,int t) { fill(dis.begin(),dis.end(),0); dis[s]=1;queue\u0026lt;int\u0026gt; que;que.push(s); while(!que.empty()) { auto u=que.front();que.pop();rad[u]=H1[u]; for(int i=H1[u];i!=-1;i=G[i].nxt) { int v=G[i].to; if(!dis[v]\u0026amp;\u0026amp;G[i].cap) dis[v]=dis[u]+1,que.push(v); } } return dis[t]; } int augment(int u,int ref,int t) { if(u==t||!ref) return ref;int nrf=ref; for(int i=H1[u];i!=-1\u0026amp;\u0026amp;nrf;i=G[i].nxt) { int v=G[i].to;rad[u]=i; if(dis[v]==dis[u]+1\u0026amp;\u0026amp;G[i].cap) { int aug_min=min(G[i].cap,nrf),dlta=augment(v,aug_min,t); G[i].cap-=dlta,G[i^1].cap+=dlta;nrf-=dlta; if(!nrf) break; } } return ref-nrf; } int dinic(int s,int t) { int ans=0; while(delaminate(s,t)) ans+=augment(s,inf,t); return ans; } void clear() { //for(int i=1;i\u0026lt;=vnm;++i) H1[i]=-1; cnt1=0,vnm=0; } int _s,_t; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;_s=1,_t=n+m+2; vnm=2+n+m;for(int i=1;i\u0026lt;=vnm;++i) H1[i]=-1; for(int i=2;i\u0026lt;=n+1;++i) add_r(_s,i,1); for(int i=n+2;i\u0026lt;=n+m+1;++i) add_r(i,_t,1); dis=vector\u0026lt;int\u0026gt;(vnm+2,0); vector\u0026lt;int\u0026gt; oprs[2];rad=vector\u0026lt;int\u0026gt;(vnm+2,0); oprs[0].resize(n+1),oprs[1].resize(n+1); for(int i=1;i\u0026lt;=n;++i) { int iu,iv;cin\u0026gt;\u0026gt;iu\u0026gt;\u0026gt;iv; //cout\u0026lt;\u0026lt;iu+n+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;iv+n+1\u0026lt;\u0026lt;endl; oprs[0][i]=cnt1;add_r(i+1,iu+n+1,1); oprs[1][i]=cnt1;add_r(i+1,iv+n+1,1); } int chk=dinic(_s,_t);//cout\u0026lt;\u0026lt;chk\u0026lt;\u0026lt;endl; if(chk\u0026lt;n) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl;return clear(); } else cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; //for(int i=0;i\u0026lt;=cnt1;++i) cout\u0026lt;\u0026lt;G[i].to\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=n;++i) { int e0=oprs[0][i],e1=oprs[1][i]; assert((e0\u0026amp;1)==0);assert((e1\u0026amp;1)==0); if(G[e0^1].cap) cout\u0026lt;\u0026lt;G[e0].to-1-n\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;G[e1].to-1-n\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; return clear(); } void file(string file) { freopen((file+\u0026#34;.in\u0026#34;).c_str(),\u0026#34;r\u0026#34;,stdin); freopen((file+\u0026#34;.out\u0026#34;).c_str(),\u0026#34;w\u0026#34;,stdout); } /* 1 5 5 1 3 4 5 2 5 1 4 3 5 */ int main() { syncoff(); cin\u0026gt;\u0026gt;t; while(t--) solve(); return 0; } 特殊性质：A 我们考虑构出这种图：每个右部点的度数最大也为 $2$，原图可以分解为若干条夹杂着左右部点的链，并且一定满足 $n\\le m$，因此此时一定有解，解也容易构造，可以在线性时间内处理。\n特判所有右部点的度数即可处理这种特殊情况。\n有趣的是，Dinic算法跑这种情况嘎嘎快，并不需要特殊处理就可以通过。\n缝合 如果您只会爆搜，只要敢于不可以总司令，搞定特殊性质B，可以拿到 $35$ 分。\n如果您想到了二分图但不会网络流，并且敢于大胆不可以总司令，您可以再拿 $5$ 分整到最多 $60$ 分。如果还能搞定特殊性质A，您还可以再搞 $10$ 分。\n如果您是网络流领域大神，并且写了Dinic，特殊性质A的点直接可过，加上一个不可以总司令，$80$ 分到手。\n正解 通过特殊性质A的链状结构，我们发现：链的两个端点一定是代表Vtuber的右部点，并且代表颠佬的左部点总是被两个右部点夹在中间。\n进一步思考一般情况，发现后者对所有情况都成立。\n我们从特殊性质A考虑：实际上解的构造就是对每个左部点选择其两端的任意一个右部点端点，使每个右部点最多被选择一次。\n由此，我们重新建图：把Vtuber看成点，每个颠佬看成连在他推的两个Vtuber之间的边，选择某个Vtuber则视为将这条边定向为指向那个Vtuber，那么，存在解的充要条件就成为了：存在一种给边定向的方案，使每个点的入度均不超过 $1$。\n我们冷静思考下这个条件，发现单个连通分量能满足这个条件时，它要么是树，要么是基环树。\n因此，此时有解的充要条件转化为：该图的所有连通分量要么是树要么是基环树。\n首先是判定：直接对每个连通分量求出点数和边数，若满足 $\\mid E\\mid \\le \\mid V\\mid$ ，不等时为树，相等时为基环树。\n如果有解，构造算法如下：对于树，直接任找一个点作为根，边定向为叶向树即可。\n对于基环树，先不考虑环上的边，以环为根，将所有边都定为叶向：对于环上的边，全部取一个方向即可。\n以上所有步骤均可以通过DFS在线性时间内完成，时间复杂度 $\\Theta(n+m)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 //written by Amekawa_kanade #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; void syncoff()//fuck you sync { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); } #define endl \u0026#39;\\n\u0026#39; const int N=2e6+11; using ll=long long; int t,n,k,m,q; struct edge { int to,nxt,id; }G[N*2];int cnt1=1,H1[N]; inline void add_edge(int u,int v,int id) { G[++cnt1]=edge{v,H1[u],id};H1[u]=cnt1; } int cid,vcnt[N],ecnt[N],cidu[N]; bitset\u0026lt;N\u0026gt; vis; bool evis[N*2]; #define RAPE(i,x) for(int i=H1[x];i;i=G[i].nxt) void dfs1(int u,int f,int id) { ++vcnt[id];vis[u]=1; RAPE(i,u) { auto v=G[i].to; if(i==(f^1)||evis[i]) continue; evis[i]=evis[i^1]=1; ++ecnt[id];if(!vis[v]) dfs1(v,i,id); } } int idx,dfn[N],fa[N]; vector\u0026lt;int\u0026gt; loops[N]; void find_loop(int u,int id) { dfn[u]=++idx; RAPE(i,u) if(G[i].to!=fa[u]) { auto v=G[i].to; if(dfn[v]\u0026amp;\u0026amp;dfn[v]\u0026gt;dfn[u]) { loops[id].push_back(v); vis[v]=1; auto y=v; while(y!=u) { loops[id].push_back(fa[y]); vis[fa[y]]=1; y=fa[y]; } } else if(!dfn[v]) { fa[v]=u;find_loop(v,id); } } } int ans[N]; void dfs2(int u,int f) { RAPE(i,u) { auto v=G[i].to; if(v==f||vis[v]) continue; //cout\u0026lt;\u0026lt;G[i].id\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; ans[G[i].id]=v;dfs2(v,u); } } bitset\u0026lt;N\u0026gt; vis2; void dfs3(int u,int f,int id) { vis2[u]=1; RAPE(i,u) { auto v=G[i].to; if(v==f) continue; if(v==id) { ans[G[i].id]=id;return; } if(vis2[v]||!vis[v]) continue; ans[G[i].id]=v;//cout\u0026lt;\u0026lt;G[i].id\u0026lt;\u0026lt;\u0026#34;::\u0026#34;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; dfs3(v,u,id); } } void clear() { for(int i=1;i\u0026lt;=cnt1+11;++i) evis[i]=0; for(int i=1;i\u0026lt;=n;++i) fa[i]=dfn[i]=H1[i]=vis[i]=vis2[i]=0;idx=0; cnt1=1; for(int i=1;i\u0026lt;=m;++i) ans[i]=0; for(int o=1;o\u0026lt;=cid;++o) { loops[o].clear(); vcnt[o]=ecnt[o]=0; cidu[o]=0; } cid=0; } void solve() { cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=m;++i) { int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;//cout\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; add_edge(u,v,i);add_edge(v,u,i); } if(n\u0026lt;m) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; clear(); return; } for(int i=1;i\u0026lt;=n;++i) if(!vis[i]) dfs1(i,-1,++cid),cidu[cid]=i; for(int i=1;i\u0026lt;=cid;++i) { //cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ecnt[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;vcnt[i]\u0026lt;\u0026lt;endl; if(ecnt[i]\u0026gt;vcnt[i]) { clear(); cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return; } } for(int i=1;i\u0026lt;=n;++i) vis[i]=0; for(int i=1;i\u0026lt;=cid;++i) { if(!vcnt[i]) continue; else if(vcnt[i]==ecnt[i]) { find_loop(cidu[i],i); for(auto x:loops[i]) dfs2(x,0); auto rtp=loops[i][0]; dfs3(rtp,0,rtp); } else dfs2(cidu[i],0); } cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;++i) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; clear(); //fflush(stdout); } void file(string file) { freopen((file+\u0026#34;.in\u0026#34;).c_str(),\u0026#34;r\u0026#34;,stdin); freopen((file+\u0026#34;.out\u0026#34;).c_str(),\u0026#34;w\u0026#34;,stdout); } int main() { syncoff(); //file(\u0026#34;11\u0026#34;); cin\u0026gt;\u0026gt;t;//cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; while(t--) solve(); return 0; } /* 5 5 1 3 4 5 2 5 1 4 3 5 */ 题外话 本题的checker实现：首先用 std 生成该测试点的判定文件，这个判定文件说明测试点的每个子任务是否有解。\nchecker首先读取这个判定文件，之后对于每个测试点，先对照是否有解，若有解且回答正确，对于方案的判定就是爆搜那一套。\n","date":"2024-09-23T22:01:23+08:00","permalink":"http://localhost:1313/p/p0011/","title":"P0011"},{"content":"这个问题一眼看是一个排列组合问题，但是由于限制条件 $k$ 的关系，不能直接通过乘积得到，观察题意发现，求得是对方案数取模，这样如果直接用乘法原理往往需要用到逆元，所以一般这样方案数，就考虑 $dp$。\ndp 状态定义 对于 $dp$ 问题，定义状态往往是最难的，状态的定义是否正确合理则决定了做法是否正确和简洁 ——一个我忘了哪个大佬说的 我开始设定的转态定义是 $dp_{i,j,k,0/1}$ 表示前 $i$ 个位置，放 $j$ 个黑球，以黑球 $(1表示黑球)$ 结尾，连续长度为 $k$ 的状态定义，后来发现状态定义是不正确的，因为发现可能会出现当 $k==3$ ，xxxoooxxx 会被理解为正确状态，所以舍弃。后来考虑 $dp_{i,j,Q,W}$ 表示前 $i$ 个位置，放 $j$ 个黑球，后缀为最大黑球比白球多 $Q$ 个，白球比黑球多 $W$ 个，这个转态定义可以把每种状态都包含进去，而且是正确的。\n状态正确性证明 当每添加一个黑球或白球，它构成的合法方案是由原来合法状态得来的，而它添进去的数的方案也必须合法，所以检验一个方案是否合法只需要检验新构成的方案是否合法即可，而新构成的方案必然造成的是对后缀的改变，那么只需要对后缀进行限制即可。该状态满足，所以状态正确。（感觉证明写的好像在水字数）\n由于 $i,j$ 表示前 $i$ 个位置有 $j$ 个黑球，本质上等价于前 $i+j$ 个位置上放了 $i$ 个黑球，$j$ 个白球，于是转态定义就更新成 $dp_{i,j,Q,W}$ 表示放 $i$ 个黑球，放 $j$ 个白球，后缀为最大黑球比白球多 $Q$ 个，白球比黑球多 $W$ 个\n状态转移 这次状态转移分为两个，一个是递推的转移，另一个是递归的记忆化搜索。\n递推的状态转移 初始转态：$dp_{1,0,1,0}=dp_{0,1,0,1}=1$，分别表示第一个球放入黑球还是白球的情况。\n转移：$dp_{i,j,q,w}=dp_{i-1,j,q-1,w+1}+dp_{i,j-1,q+1,w-1}$\n还有一种情况，当 $q==0$ 且要放入白球时，$dp_{i,j,0,w}+=dp_{i,j-1,0,w-1}$ 对于白球亦然，当 $w==0$ 且要放入黑球时，$dp_{i,j,q,0}+=dp_{i-1,j,q-1,0}$\n统计答案就是当黑白球都被填充进去，所有的合法方案数加在一起。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; #define LL long long int n, m, K; LL ans; const int MOD = 1e9 + 7; LL dp[200][200][30][30]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; dp[1][0][1][0] = 1; dp[0][1][0][1] = 1; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { for (int q = 0; q \u0026lt;= K; q++) { for (int w = 0; w \u0026lt;= K; w++) { if (q \u0026gt;= 1 \u0026amp;\u0026amp; i \u0026gt;= 1) { dp[i][j][q][w] = (dp[i][j][q][w] + dp[i - 1][j][q - 1][w + 1]) % MOD; if (w == 0) dp[i][j][q][w] = (dp[i][j][q][w] + dp[i - 1][j][q - 1][0]) % MOD; } if (w \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026gt;= 1) { dp[i][j][q][w] = (dp[i][j][q][w] + dp[i][j - 1][q + 1][w - 1]) % MOD; if (q == 0) dp[i][j][q][w] = (dp[i][j][q][w] + dp[i][j - 1][0][w - 1]) % MOD; } } } } } for (int i = 0; i \u0026lt;= K; i++) { for (int j = 0; j \u0026lt;= K; j++) { ans = (ans + dp[n][m][i][j]) % MOD; } } cout \u0026lt;\u0026lt; ans; return 0; } 递归的记忆化转移 对于状态 $dp_{i,j,Q,W}$ :\n当 $i\\leq n$ 且 $Q\\leq K$ 时可以放下白球，转移至 $dp_{i+1,j,Q+1,.max(0,W-1)}$ 当 $j\\leq m$ 且 $W\\leq K$ 时可以放下白球，转移至 $dp_{i,j+1,max(Q-1,0),W+1}$ 时间复杂度 $O(nmk^2)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; const int mod = 1e9 + 7; typedef long long LL; LL dp[200][200][30][30]; int n, m, K; LL dfs(int i, int j, int q, int w) { if (i == n \u0026amp;\u0026amp; j == m) return 1; if (dp[i][j][q][w] != -1) return dp[i][j][q][w]; LL tmp = 0; if (i \u0026lt; n \u0026amp;\u0026amp; q \u0026lt; K) { tmp = (tmp + dfs(i + 1, j, q + 1, max(0, w - 1))) % mod; } if (j \u0026lt; m \u0026amp;\u0026amp; w \u0026lt; K) { tmp = (tmp + dfs(i, j + 1, max(0, q - 1), w + 1)) % mod; } return dp[i][j][q][w] = tmp; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; for (int i = 0; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= m; j++) for (int q = 0; q \u0026lt;= K; q++) for (int w = 0; w \u0026lt;= K; w++) dp[i][j][q][w] = -1; cout \u0026lt;\u0026lt; dfs(0, 0, 0, 0); return 0; } ","date":"2024-09-18T20:59:19+08:00","permalink":"http://localhost:1313/p/p0010%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/","title":"P0010你的名字"},{"content":"快排骗25pts。 用了个快排（循环内的），下面欣赏我低级的快排艺术\n1 for(int i=0;i\u0026lt;=n;i++) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if(i!=0) { while(h\u0026lt;i) { h++;aa[h]=p[h].b; } sort(aa+1,aa+h+1); int qw=h; for(int f=1;f\u0026lt;=h;f++) { if(h\u0026gt;=m1)break;qw++; while(p[qw].a\u0026lt;aa[f]\u0026amp;\u0026amp;qw+1\u0026lt;=m1)qw++; if(qw\u0026lt;m1) { h++,aa[h]=p[qw].b,r++; } if(qw==m1){if(p[qw].a\u0026gt;=aa[f])h++;break; } sort(aa+r,aa+h+1); } } 本来就以为是 $ 20$ 分，没想到 $#16$ 竟然过了，所以拿了 $25$ 分。\n接下来是正题!!! 对于模拟的话， 我们只需要考虑模拟廊桥的数量当廊桥数有的就 $t++$,没有的直接舍去考虑下一个飞机，然后一直循环到结束。所以我们要先讲飞机的出发时间进行快排，在之后建立一个自定义的优先队列，用来维护结束时间最早的飞机，然后当下一个飞机来的出发时间时候和队列的 $top$ 作比较，如果大于就将其堆入队列，否则就是下一个飞机（注意模拟的是廊桥数所以要保证廊桥一直处于被占满的状态） 时间复杂度 $O(nm\\ logn)$，其实是 $40$ 分，可能 $CCF$ 数据有问题 $#16$ 就是能过（快排也行）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;queue\u0026gt; #define mm 1100000 using namespace std; int n,m1,m2,j,h,g,ans; struct nihao{ int a;int b; bool operator\u0026lt;(const nihao \u0026amp; u) const { return b\u0026gt;u.b; } }; nihao t[mm],p[mm]; int cmp(nihao x,nihao y) { return x.a\u0026lt;y.a; } int main () { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m1,\u0026amp;m2); for(int i=1;i\u0026lt;=m1;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;p[i].a,\u0026amp;p[i].b); sort(p+1,p+m1+1,cmp); for(int i=1;i\u0026lt;=m2;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;t[i].a,\u0026amp;t[i].b); sort(t+1,t+m2+1,cmp); for(int i=0;i\u0026lt;=n;i++) { priority_queue\u0026lt;nihao\u0026gt; q; priority_queue\u0026lt;nihao\u0026gt; w; j=n-i,h=0,g=0; if(i) { while(h\u0026lt;i) { h++;q.push(p[h]); } int qw=h; while(q.size()==i){ if(h\u0026gt;=m1)break; qw++; while(p[qw].a\u0026lt;q.top().b\u0026amp;\u0026amp;qw+1\u0026lt;=m1)qw++; if(qw\u0026lt;m1)\th++,q.push(p[qw]),q.pop(); if(qw==m1){if(p[qw].a\u0026gt;=q.top().b)h++;break; } } } if(j) { while(g\u0026lt;j) { g++;w.push(t[g]); } int qw=g; while(w.size()==j){ if(g\u0026gt;=m2)break;qw++; while(t[qw].a\u0026lt;w.top().b\u0026amp;\u0026amp;qw+1\u0026lt;=m2)qw++; if(qw\u0026lt;m2) g++,w.push(t[qw]),w.pop(); if(qw==m2){if(t[qw].a\u0026gt;=w.top().b)g++;break; } } } if(h+g\u0026gt;ans)ans=h+g; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 接下来就是正解了。 我们可以考虑两个优先队列进行维护。 一个维护廊桥的序号，另一个维护飞机的时间。 对于这个题我们求当每一个飞机到达机场时有几个廊桥是空余的（以飞机编号循环）， 如果有多个空余， 优先选择编号靠前的廊桥这样可以使飞机数最大化（要标记上它所在廊桥的编号）， 因为对于一个飞机所在廊桥的编号 $t$ ，在分配的廊桥数 $\u0026gt;=t$ 时，它都会停在那里。 让后就只需要开一个数组 $m$ 来求前缀和。（国外机场复制粘贴即可） 注意看注释（很重要）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;queue\u0026gt; #define mm 1100000 using namespace std; int n,m1,m2,ans; int x[mm],y[mm]; struct nihao{ int a;int b; bool operator\u0026lt;(const nihao \u0026amp; u) const { return a\u0026gt;u.a; } }; pair\u0026lt;int,int\u0026gt; t[mm],p[mm]; int main () { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m1,\u0026amp;m2); for(int i=1;i\u0026lt;=m1;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;p[i].first,\u0026amp;p[i].second); sort(p+1,p+m1+1); for(int i=1;i\u0026lt;=m2;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;t[i].first,\u0026amp;t[i].second); sort(t+1,t+m2+1); priority_queue\u0026lt;nihao\u0026gt; q;//a存结束时间 ，b存该飞机停在廊桥的编号 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; k; for(int i=1;i\u0026lt;=m1;i++)k.push(i); for(int i=1;i\u0026lt;=m1;i++)// { /* 3 5 4// k1 3 k2 1 1 5 //1 3 8/6 //2 6 10 //1 9 14 //2 13 18 //1 k 1 2 1 2 1 q 5,1 8,2 10,1 14,2 18,1 */ while (!q.empty()\u0026amp;\u0026amp;q.top().a\u0026lt;=p[i].first) //找到可以的接的位置，因为这个飞机的时间是较后面都早的（本质是判断这个飞机到达时有多少个空缺的位置） { k.push(q.top().b);//意味着有个位置空出来了，而空出来的位置就是q队列里面最早离开的 q.pop();//删掉该飞机的编号和所占的廊桥位置 } x[k.top()]++;//无论这个是否能接到某些飞机的后面，它接的位置总是空缺的（因为它所在的廊桥编号可以i\u0026gt;n） q.push((nihao){p[i].second,k.top()});//推入它离开的时间和离开的位置 k.pop(); //删除该位置 } priority_queue\u0026lt;nihao\u0026gt; w; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; j; for(int i=1;i\u0026lt;=m2;i++)j.push(i); for(int i=1;i\u0026lt;=m2;i++) { while (!w.empty()\u0026amp;\u0026amp;w.top().a\u0026lt;=t[i].first) { j.push(w.top().b); w.pop(); } y[j.top()]++; w.push((nihao){t[i].second,j.top()}); j.pop(); } for(int i=1;i\u0026lt;=n;i++)x[i]+=x[i-1]; for(int i=1;i\u0026lt;=n;i++)y[i]+=y[i-1]; for(int i=0;i\u0026lt;=n;i++) ans=max(ans,x[i]+y[n-i]); printf(\u0026#34;%d\u0026#34;,ans); return 0; } ","date":"2024-09-07T21:27:48+08:00","permalink":"http://localhost:1313/p/p0009%E5%BB%8A%E6%A1%A5%E5%88%86%E9%85%8D/","title":"P0009廊桥分配"},{"content":"简述 给定一串全为 $1$ 的数列，再给定一个集合 $P$，经过三种操作使该数列变为 $p_i$ 的位置为 $1$ 其余的位置都为 $0$。\n三种操作中，每个操作的每个下标都有各自操作的代价，即要最小化操作代价和，即考虑 $dp$。\n思路 操作分为三种，\n操作 $a$ 将前缀 $v_i$ 全部变为 $0$。 操作 $b$ 将单个下标 $v_i$ 赋值为 $0$。 操作 $c$ 将单个下标 $v_i$ 赋值为 $1$。 可观察到，操作 $a$ 和 $b$ 有相似之处，倘如将 $b$ 操作执行 $i$ 遍其操作就等价于一个 $a_i$。易知前缀操作可以求出最小值，即 $a_i=min(a_i,\\sum b_i)$。\n进一步考虑，$a_i$ 和 $b_i$ 可以同时操作，即前缀操作最小值也要 $dp$，每一步新的 $a_i$ 可由两种操作而来。\n$a_i=a_{i-1}+b_i$，$a_i$ 可以由 $a_{i-1}$ 转移过来。 $a_i=min(a_i,\\sum b_i)$，直接比较两个前缀数组的大小。 即前缀操作最小值的方程即为 $a_i=min(min(a_i,\\sum b_i),a_{i-1}+b_i)$。\n之后考虑如何 $dp$。\n对于每个下标为 $p_i$ 时，保证该下标为 $1$，此刻也需要决策，不能直接 $dp_i=dp_ {i-1} $，因为满足此刻的条件还有其他两种操作可以满足，$dp_i=a_i+c_i$，$dp_i=a_{i-1}$。\n考虑到 $p_i$ 下标不一定为第一个所以可以开一个变量 $sum$ 专门存所有下标为 $p_i$ 的 $c_i$ 值。 即对于每个下标为 $p_i$ 时 $dp_i=min(dp_{i-1},a_i+sum,a_{i-1}+sum-c_i)$。\n对于下标不为 $p_i$ 时，$dp_i=min(dp_{i-1}+b_i,a_i+sum)$。\n此刻复杂度为 $O(qn)$，绝对假。\n显然我们发现对于数组 $b$ 完全不用一遍遍的加，可以直接使用前缀和数组 $b$，其次发现对于位置为非 $p_i$ 的位置其实不需要考虑，$dp$ 数组的继承可以直接由 $i-1$ 变为 $p_{i-1}$ 。\n而为什么这样子，观察下标不为 $p_i$ 的方程， $dp_i=min(dp_{i-1}+b_i,a_i+sum)$，将数组 $b$ 变为前缀数组， $dp$ 方程变为 $dp_i=min(dp_{i-1}+b_i-b_{i-1},a_i+sum)$。\n而对于 $a_i+sum$,这是对于每一步都需要进行的转移，直到下标为 $p_i$ 依然这样转移。\n其中有一步贪心,若在非 $p_i$ 位置中，存在一点 $i$ 使得 $a_i+sum\u0026lt;dp_{i-1}+b_i-b_{i-1}$，那么从该点之后到下一个 $p_i$ 之前总存在 $a_i+sum\\leq dp_{i-1}+b_i-b_{i-1}$。\n因为 $a_i+sum$ 的意思是把前缀全变为 $0$，再加上之前 $P_i$ 位置变为 $1$ 的代价。那么该点 $i$ 推出的 $dp$ 状态转移中 $dp_{i-1}+b_i-b_{i-1}$ 也等价于把前缀全变为 $0$，再加上之前 $P_i$ 位置变为 $1$ 的代价。 而前缀操作最小值已经预处理过了，所以贪心成立。\n所以可以直接将两个 $dp$ 方程合并成一个，枚举每一个 $p_i$ 即可。 此刻的数组 $b$ 为操作 $b$ 的前缀和数组。 $dp_{p_i}=min(dp_{p_{i-1}}+b_{p_{i}-1}-b_{p_{}i-1},a_{p_i}+sum,a_{p_i-1}+sum-c_{p_i})$。\n最后只需要特判一下 $p_m$ 是否恰好等于 $n$，再单独 $dp$ 一遍即可。\n由于 $dp$ 转移时初始状态为由 $dp_0$ 开始，所以不用更新数组。\n这样复杂度降为了 $O(\\sum m)$，即 $O(n)$。\n记得开 $long long $！！！\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int a[610000],b[610000],c[610000],p[610000]; int dp[610000],s[610000]; #define re read() int read(){ int data = 0, w = 1; char ch = 0; while (!isdigit(ch) \u0026amp;\u0026amp; ch != \u0026#39;-\u0026#39;) ch = getchar(); if (ch == \u0026#39;-\u0026#39;) w = -1, ch = getchar(); while (isdigit(ch)) data = 10 * data + ch - \u0026#39;0\u0026#39;, ch = getchar(); return w * data; } void qwrite(int x,char ed=\u0026#39;\\n\u0026#39;) { if(!x) {putchar(\u0026#39;0\u0026#39;),putchar(ed);return;} char w[44];int cnt=0; if(x\u0026lt;0) putchar(\u0026#39;-\u0026#39;),x=-x; while(x) w[++cnt]=(x%10)+\u0026#39;0\u0026#39;,x/=10;++cnt; while(--cnt) putchar(w[cnt]);putchar(ed); } int n,q; int Min(int x,int y,int z) { x=min(x,y);x=min(x,z);return x; } void init() { for(int i=1;i\u0026lt;=n;i++)a[i]=re;for(int i=1;i\u0026lt;=n;i++)b[i]=re,b[i]+=b[i-1];for(int i=1;i\u0026lt;=n;i++)c[i]=re; for(int i=1;i\u0026lt;=n;i++)\ta[i]=Min(a[i],b[i],a[i-1]+b[i]-b[i-1]); } signed main() { n=re; init(); q=re; while(q--) { int m=re;int sum=0; for(int i=1;i\u0026lt;=m;i++) { p[i]=re;sum+=c[p[i]]; dp[p[i]]=Min(dp[p[i-1]]+b[p[i]-1]-b[p[i-1]],a[p[i]]+sum,a[p[i]-1]+sum-c[p[i]]); } if(p[m]==n){qwrite(dp[n]);continue;} dp[n]=min(dp[p[m]]+b[n]-b[p[m]],a[n]+sum); qwrite(dp[n]); } return 0; } ","date":"2024-09-06T21:21:46+08:00","permalink":"http://localhost:1313/p/p0002%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97/","title":"P0002消除序列"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"}]