[{"content":"友好的主席树 前言自述 这是一道刚学主席树的练习题，就很适合我这样的人写。不过对于我而言，刚开始没有太理解主席树的本质，就想得有点累。\n比如说我们刚学主席树时是求区间第 $k$ 小，然后就会把有关的数往求第 $k$ 小的方面考虑。但是主席树的本质是就是多个线段树的维护，由于新建线段树会和原来的有很多相同的结点，所以我们每开一个新线段树只需要开一个新的根结点和修改一条链即可。\n对于本道题而言，我们维护的就是区间内某个数出现的次数不是区间第 $k$ 小了。我们先开一个线段树，由于每次添加一个数都要修改树的结点，所以还是要用主席树。\n分析 给定一个集合数列，求给定的区间集合内内最小不能被表示的数。 这个题有相似思路的题：P5020 货币系统 。\n这个题会想到集合的思想，给定一个当前集合中最小不能被表示的数为 $ans$，在此集合中，若对于一个数 $x$ 可以被该集合中其它的数表示出来，且在小于 $x$ 的数中在该集合中也均可以被表示出来或者本来就有，那么可以将 $x$ 填入集合，这样表示出来的范围就由 $ans-1$ 扩展到了 $ans+x-1$ 。\n那么我们下一次加入的数就是在 $[x,ans+x-1]$ 之间的数，如果该区间中的集合中没有别的数，那么此时答案就是 $ans+x$ ，如果可以填就一直扩大范围。\n查询 1 2 3 4 5 6 7 8 9 int query(int use,int now,int l,int r,int lin,int rax) { int ksum=0; if(lin\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=rax)return t[now].sum-t[use].sum; int mid=(l+r)\u0026gt;\u0026gt;1; if(lin\u0026lt;=mid)ksum+=query(t[use].l,t[now].l,l,mid,lin,rax); if(mid\u0026lt;rax) ksum+=query(t[use].r,t[now].r,mid+1,r,lin,rax); return ksum; } 对于维护添数有两种思路。\n查询所有小于 $ans$ 的区间 通过主席树求和来查询从 $[1,ans-1]$ 的区间如果求和小于等于原来的 $ans$ 就可以结束循环了，否则就一直查询，直到 $Sum==ans$ 为止。\n1 2 3 int Sum=query(rt[l-1],rt[r],1,inf,1,ans); if(Sum\u0026lt;ans)break; else ans=Sum+1; 在填入的数 $x$ 后，查询区间 $[x+1,ans]$ 在查询的区间中如果有数那么 $ans+=Sum$ 否则退出循环 。\n1 2 3 4 int Sum=query(rt[l-1],rt[r],1,inf,last+1,ans); last=ans; if(!Sum)break; else ans+=Sum; 维护 1 2 3 4 5 6 7 8 9 10 void modify(int \u0026amp;xi,int x,int l,int r,int inst) { xi=++nodee; t[xi]=t[x];t[xi].sum+=inst; if(l==r)return ; int mid=(l+r)\u0026gt;\u0026gt;1; if(inst\u0026lt;=mid) modify(t[xi].l,t[x].l,l,mid,inst); else modify(t[xi].r,t[x].r,mid+1,r,inst); return ; } 注意不用像刚学主席树一样先建树，直接动态开点即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include\u0026lt;bits/stdc++.h\u0026gt; #define mm 2000009 #define w qwrite #define gc getchar()\tusing namespace std; struct nihao { int fre,l,r,sum,nl,nr; }t[mm\u0026lt;\u0026lt;2]; int rt[mm\u0026lt;\u0026lt;2]; int a[mm]; int nodee; int n,m,k=1e9; int anss,ans,last; const int inf=1e9; int read() { int data = 0, w = 1; char ch = 0; while (!isdigit(ch) \u0026amp;\u0026amp; ch != \u0026#39;-\u0026#39;) ch = getchar(); if (ch == \u0026#39;-\u0026#39;) w = -1, ch = getchar(); while (isdigit(ch)) data = 10 * data + ch - \u0026#39;0\u0026#39;, ch = getchar(); return w * data; } void modify(int \u0026amp;xi,int x,int l,int r,int inst) { xi=++nodee; t[xi]=t[x];t[xi].sum+=inst;t[xi].nl=l,t[xi].nr=r; if(l==r)return ; int mid=(l+r)\u0026gt;\u0026gt;1; if(inst\u0026lt;=mid) modify(t[xi].l,t[x].l,l,mid,inst); else modify(t[xi].r,t[x].r,mid+1,r,inst); return ; } int query(int use,int now,int l,int r,int lin,int rax) { int ksum=0; if(lin\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=rax)return t[now].sum-t[use].sum; int mid=(l+r)\u0026gt;\u0026gt;1; if(lin\u0026lt;=mid)ksum+=query(t[use].l,t[now].l,l,mid,lin,rax); if(mid\u0026lt;rax) ksum+=query(t[use].r,t[now].r,mid+1,r,lin,rax); return ksum; } signed /*int*/ main () { int l,r; n=read(); for(int i=1;i\u0026lt;=n;i++) { a[i]=read(); modify(rt[i],rt[i-1],1,inf,a[i]);} m=read(); while(m--) { l=read(),r=read();ans=1,last=0; for(int i=1;i+1-1\u0026lt;=1;i) { int Sum=query(rt[l-1],rt[r],1,inf,last+1,ans); last=ans; if(!Sum)break; else ans+=Sum; /* int Sum=query(rt[l-1],rt[r],1,inf,1,ans); if(Sum\u0026lt;ans)break; else ans=Sum+1;*/ } printf(\u0026#34;%d\\n\u0026#34;,ans); } return 0; } ","date":"2024-09-06T20:58:53+08:00","permalink":"http://localhost:1313/p/shenmishu/","title":"Shenmishu"},{"content":"昨天的周赛题目没来的及打，今天在图书馆调了一下午，很显然在75分钟内这题必挂。 我最开始定义了一堆没用的状态和转移，浪费了好几张草稿纸。但在定义状态和转移的过程中我把每个状态都精确的分了出来，以及最开始的填充和特判状态，就显得代码很长，像循环展开一样。\n题意 给定一个字符串样的地图，字符串中只有 $1,2,,?,0$ 五种字符，可在字符为 $?$ 的字符中填充 $0,1, 2,$ 这 $4$ 类字符，求所有不同的合法数量的地图(字符串)。\n限制条件 若第 $i$ 位置字符的左右两边，有（或可填充） $j$ 个雷($*$)，那么该 $i$ 位置就填充 $j$ 。 题面数据 $1\\leq n\\leq10^6$ ，那么必然不能直接模拟某个位置填充什么的所有情况，不进行状态转移，这样复杂度会，额就是会很费手感觉至少得 $O(n^4)$ 。\n分析 由于题目给了一个字符串，可以发现第 $i$ 个位置的方案数总可以由第 $i-1$ 个位置的方案数推导出来，显然考虑 $dp$ 。关于状态如何定义和转移，这个开始思考了很久。 首先会想到在 $i$ 位置填充数字 $j$ （数字 $3$ 可以代表雷）的方案数，其实这样定义大概率也是可以的，就是会比较麻烦，因为需要考虑是否有雷，根据是否有雷状态转移会很麻烦，那么倒不如单独把是否有雷拎出来，定义一个三维 $dp$ 。\n对于 $dp$ 问题，定义状态往往是最难的，状态的定义是否正确合理则决定了做法是否正确和简洁 ——一个我忘了哪个大佬说的\n那么此时状态定义就很清楚了，$dp_{i,j,k}$ 分别表示在第 $i$ 位置填充数字 $k$ 的方案数， $j$ 判断上一个位置是否有雷，$k$ 代表填充的数字。\n考虑状态转移 对于填充的数字 $0,1,2,3$\n0 状态只能由 $*1?$ 和 $00?$ 这两种状态转移过来。 1 dp[i][0][0] = dp[i - 1][1][1] + dp[i - 1][0][0]; 1 状态可以由 $*?,*1?,0?$ 三种大的状态来转移。 前面含雷的也单独分出来两种，包括含雷的前面是否有雷的两种状态。 前面不含雷只能由前面是 $0$ 或者是 $1$ 且 $1$ 的前面必须有雷，因为我们此时填充的不含雷，若 $1$ 左右两边均不含雷是不合法的。 1 2 dp[i][1][1] = dp[i - 1][1][3] + dp[i - 1][0][3]; dp[i][0][1] = dp[i - 1][0][0] + dp[i - 1][1][1]; 2 状态可以由 $*?$ 这一种大的情况得到。 前面含雷的也单独分出来两种，包括含雷的前面是否有雷的两种状态。 1 dp[i][1][2] = dp[i - 1][1][3] + dp[i - 1][0][3]; 3（即 $$ 雷） 状态可以由 $?,01?,11?,*2?$ 这三种大情况得到。 $01?,11?$ 这两种情况都是 $dp_{i-1,0,1}$ 这一种情况。 同样前面含雷分两种小情况，再加上一个 $2$ 的情况即可。 1 2 dp[i][1][3] = dp[i - 1][1][3] + dp[i - 1][0][3]; dp[i][0][3] = dp[i - 1][0][1] + dp[i - 1][1][2]; 即状态转移已经处理好了，接下来把条件初始化一下即可。 直接放代码吧，处理和状态转移的很像。\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (s[0] == \u0026#39;?\u0026#39;) dp[0][0][1] = dp[0][0][0] = dp[0][0][3] = dp[0][1][3] = 1; else if (s[0] == \u0026#39;2\u0026#39;) { cout \u0026lt;\u0026lt; 0; return 0; } else if (s[0] == 1) dp[0][0][1] = 1; else if (s[0] == \u0026#39;*\u0026#39;) dp[0][0][3] = dp[0][1][3] = 1; else if (s[0] == \u0026#39;0\u0026#39;) dp[0][0][0] = 1; 坑点:对于第一次 $?$ 在填充数字的时候转移，对于含雷的情况要单独特判为 $1$。\n1 2 3 if (i == 1) for (int j = 1; j \u0026lt;= 3; j++) dp[i][1][j] = 1; 题面说有不合法的情况，对于我们特判不合法只需要特判第一个字符即可，至于字符串内部不合法的情况会在转移的时候变成 $0$ 。无需考虑。\n答案统计，必然是统计最后一个位置，需要考虑当填充的数字数 $2$ 或最后一个位置前面没有雷却填充了数字 $1$ 。\n复杂度 $O(n+T)$ $T$ 是一个巨大的常数，取决于 $?$ 的数量。\n最后发现，由于状态只跟 $i-1$ 有关，可以用滚动数组，降低空间复杂度。（虽然也会增加一点时间复杂度）\n","date":"2024-09-06T13:39:15+08:00","permalink":"http://localhost:1313/p/make_maps/","title":"Make_maps"},{"content":"简述 给定一串全为 $1$ 的数列，再给定一个集合 $P$，经过三种操作使该数列变为 $p_i$ 的位置为 $1$ 其余的位置都为 $0$。\n三种操作中，每个操作的每个下标都有各自操作的代价，即要最小化操作代价和，即考虑 $dp$。\nP 9744\n思路 操作分为三种，\n操作 $a$ 将前缀 $v_i$ 全部变为 $0$。 操作 $b$ 将单个下标 $v_i$ 赋值为 $0$。 操作 $c$ 将单个下标 $v_i$ 赋值为 $1$。 可观察到，操作 $a$ 和 $b$ 有相似之处，倘如将 $b$ 操作执行 $i$ 遍其操作就等价于一个 $a_i$。易知前缀操作可以求出最小值，即 $a_i=min(a_i,\\sum b_i)$。\n进一步考虑，$a_i$ 和 $b_i$ 可以同时操作，即前缀操作最小值也要 $dp$，每一步新的 $a_i$ 可由两种操作而来。\n$a_i=a_{i-1}+b_i$，$a_i$ 可以由 $a_{i-1}$ 转移过来。 $a_i=min(a_i,\\sum b_i)$，直接比较两个前缀数组的大小。 即前缀操作最小值的方程即为 $a_i=min(min(a_i,\\sum b_i),a_{i-1}+b_i)$。\n之后考虑如何 $dp$。\n对于每个下标为 $p_i$ 时，保证该下标为 $1$，此刻也需要决策，不能直接 $dp_i=dp_ {i-1} $，因为满足此刻的条件还有其他两种操作可以满足，$dp_i=a_i+c_i$，$dp_i=a_{i-1}$。\n考虑到 $p_i$ 下标不一定为第一个所以可以开一个变量 $sum$ 专门存所有下标为 $p_i$ 的 $c_i$ 值。 即对于每个下标为 $p_i$ 时 $dp_i=min(dp_{i-1},a_i+sum,a_{i-1}+sum-c_i)$。\n对于下标不为 $p_i$ 时，$dp_i=min(dp_{i-1}+b_i,a_i+sum)$。\n此刻复杂度为 $O(qn)$，绝对假。\n显然我们发现对于数组 $b$ 完全不用一遍遍的加，可以直接使用前缀和数组 $b$，其次发现对于位置为非 $p_i$ 的位置其实不需要考虑，$dp$ 数组的继承可以直接由 $i-1$ 变为 $p_{i-1}$ 。\n而为什么这样子，观察下标不为 $p_i$ 的方程， $dp_i=min(dp_{i-1}+b_i,a_i+sum)$，将数组 $b$ 变为前缀数组， $dp$ 方程变为 $dp_i=min(dp_{i-1}+b_i-b_{i-1},a_i+sum)$。\n而对于 $a_i+sum$,这是对于每一步都需要进行的转移，直到下标为 $p_i$ 依然这样转移。\n其中有一步贪心,若在非 $p_i$ 位置中，存在一点 $i$ 使得 $a_i+sum\u0026lt;dp_{i-1}+b_i-b_{i-1}$，那么从该点之后到下一个 $p_i$ 之前总存在 $a_i+sum\\leq dp_{i-1}+b_i-b_{i-1}$。\n因为 $a_i+sum$ 的意思是把前缀全变为 $0$，再加上之前 $P_i$ 位置变为 $1$ 的代价。那么该点 $i$ 推出的 $dp$ 状态转移中 $dp_{i-1}+b_i-b_{i-1}$ 也等价于把前缀全变为 $0$，再加上之前 $P_i$ 位置变为 $1$ 的代价。 而前缀操作最小值已经预处理过了，所以贪心成立。\n所以可以直接将两个 $dp$ 方程合并成一个，枚举每一个 $p_i$ 即可。 此刻的数组 $b$ 为操作 $b$ 的前缀和数组。 $dp_{p_i}=min(dp_{p_{i-1}}+b_{p_{i}-1}-b_{p_{}i-1},a_{p_i}+sum,a_{p_i-1}+sum-c_{p_i})$。\n最后只需要特判一下 $p_m$ 是否恰好等于 $n$，再单独 $dp$ 一遍即可。\n由于 $dp$ 转移时初始状态为由 $dp_0$ 开始，所以不用更新数组。\n这样复杂度降为了 $O(\\sum m)$，即 $O(n)$。\n记得开 $long long $！！！\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int a[610000],b[610000],c[610000],p[610000]; int dp[610000],s[610000]; #define re read() int read(){ int data = 0, w = 1; char ch = 0; while (!isdigit(ch) \u0026amp;\u0026amp; ch != \u0026#39;-\u0026#39;) ch = getchar(); if (ch == \u0026#39;-\u0026#39;) w = -1, ch = getchar(); while (isdigit(ch)) data = 10 * data + ch - \u0026#39;0\u0026#39;, ch = getchar(); return w * data; } void qwrite(int x,char ed=\u0026#39;\\n\u0026#39;) { if(!x) {putchar(\u0026#39;0\u0026#39;),putchar(ed);return;} char w[44];int cnt=0; if(x\u0026lt;0) putchar(\u0026#39;-\u0026#39;),x=-x; while(x) w[++cnt]=(x%10)+\u0026#39;0\u0026#39;,x/=10;++cnt; while(--cnt) putchar(w[cnt]);putchar(ed); } int n,q; int Min(int x,int y,int z) { x=min(x,y);x=min(x,z);return x; } void init() { for(int i=1;i\u0026lt;=n;i++)a[i]=re;for(int i=1;i\u0026lt;=n;i++)b[i]=re,b[i]+=b[i-1];for(int i=1;i\u0026lt;=n;i++)c[i]=re; for(int i=1;i\u0026lt;=n;i++)\ta[i]=Min(a[i],b[i],a[i-1]+b[i]-b[i-1]); } signed main() { n=re; init(); q=re; while(q--) { int m=re;int sum=0; for(int i=1;i\u0026lt;=m;i++) { p[i]=re;sum+=c[p[i]]; dp[p[i]]=Min(dp[p[i-1]]+b[p[i]-1]-b[p[i-1]],a[p[i]]+sum,a[p[i]-1]+sum-c[p[i]]); } if(p[m]==n){qwrite(dp[n]);continue;} dp[n]=min(dp[p[m]]+b[n]-b[p[m]],a[n]+sum); qwrite(dp[n]); } return 0; } ","date":"2024-09-06T13:17:52+08:00","permalink":"http://localhost:1313/p/my-first-post/","title":"My First Post"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"}]